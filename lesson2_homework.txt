Подготовка к собеседованию веб-разработчика.
Урок 2. PHP – ООП.

1. Какие типы паттернов проектирования существуют?

Банда 4-ёх разбила паттерны на 3 типа: 
    1) Порождающие паттерны
    2) Структурные паттрены
    3) Паттерны поведения

Мэтт Зандстра говорит о тех же 3 типах только в его книге они назывваются:
    1) Шаблоны для генерации объектов (Одиночка, Фабричный метод, Абстрактная фабрика и Прототип)
       Как следует из названия они служат для генерации объектов(создания экземпляров объектов) 
    2) Шаблоны для организации объектов и классов(Композиция, Декоратор, Фасад)
       Цель этих шаблонов структурировать классы так, чтобы их объекты можно было компоновать 
       в удобные структуры во время выполнения программы
    3) Шаблоны ориентированные на задачи (Интерпритатор, Стратегия, Наблюдатель, Посетитель и Комманда)
    Эти паттерны решают задачи эффективного и безопасного взаимодействия между объектами программы.
    Ещё он пишет о
    4) Промышленных щаблонах(на основе книги "Шаблоны корпоративных приложений"(Мартин Фаулер)
    5) Шаблонах баз данных

2. Как можно улучшить Singleton при помощи trait-ов?

Создав SingletonTrait мы избегаем дублирования кода так, как можем использовать его в разных классах
А для того чтобы сделать класс одиночкой, достаточно просто прописать в классе use SingletonTrait
Также такой подход решает проблему одиночного наследования в php (если сравнивать с вариантом
когда SingletonTrait оформляется в виде простого класса).

Пример реализации: 
trait SingletonTrait
{
    private static $instance = null;
    private function __clone() {}
    private function __wakeup() {}
    protected function init() {}           
    final private function __construct() {}

    public static function getInstance()
    {

        if (empty(self::$instance)) {
            self::$instance = new self();
            self::$instance->init();
        }

        return self::$instance;
    }
}

3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?

Для того, чтобы реализовать фабрику необходимо:
    1) реализовать абстрактный класс с фабричным методом, в котором непосредственно будет создаваться объект.
       Для гибкости он может быть абстрактным и он должен возвращать объект определённого типа, т.е. нужно
       указать абстрактный класс или интерфейс возвращаемого объекта

    2) реализовать абстрактный класс или интерфейс создаваемых обектов(продуктов фабрики), и объявить в нём 
    какой-то метод, который будет реализован в конкретных продуктах этой фабрики

Общая схема:

// Класс создатель с абстрактным фабричным методом factoryMethod(), возращающий объект с интерфейсом Product
abstract class Creator 
{
    abstract public function factoryMethod(): Product;
}

// Конкретный создатель, создающий объект конкретного продукта
class ConcreteCreator1 extends Creator
{
    public function factoryMethod(): Product
    {
        return new ConcreteProduct1;
    }
}
// Интефейс продуктов фабрики
interface Product
{
    public function operation(): string;
}

// Конкретный продукт данной фабрики
class ConcreteProduct1 implements Product
{
    public function operation(): string
    {
        return "{Result of the ConcreteProduct1}";
    }
}

Паттерн Абстрактная фабрика предназначена для создания целых семейств связанных объектов.
На подобии фабричного метода создаются интерфейсы нескольких продуктов. В отличии от фабричного 
метода в абстрактной фабрике создаётся интерфейс с методами для создания каждого объекта семейства.
Экземпляры конкретных фабрик реализуют разные варианты создания семейства продуктов

4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, 
__call и __callStatic. Когда, как и почему их стоит использовать (или нет)?

__get и __set применяются когда нужно получить значение или записать значение свойства объека,
имеющего модификатор доступа protected или private 
__get - выполняется автоматически при чтении данных из недоступных(не public) свойств
__set - выполняется автоматически при записи данных в недоступные(не public) свойства

__isset - применяется для проверки существования недоступных(не public) свойств. Php вызовет его 
            автоматически при вызове методов isset() и empty()
__unset - применяется при необходимости очистить значение недоступных(не public) свойств. Php вызовет 
            его автоматически при вызове методов unset()

__call - срабатывает при попытке вызова метода, не являющегося публичным в контексте объекта
__callStatic - то же самое, что __call только уже для статических методов

5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.

Двусвязный список ​- ​это список, ссылки в каждом узле которого указывают на предыдущий и на
последующий узел. По двусвязному списку можно эффективно передвигаться в любом направлении
— как к началу, так и к концу. В этом списке проще производить удаление и перестановку элементов,
так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.
В библиотеке PHP SPL с помощью них реализованы стек и очередь.

Куча - древовидная структура. В куче любой узел должен быть больше или равен своим потомкам.

Ещё в документации говорится о массивах и картах. Честно, немного не хватило времени, чтобы досконально 
разобраться в SPL, поэтому примеры использования сейчас не могу привести.

6. Найдите все ошибки в коде:

interface MyInt {
    public function funcI();
    private function funcP();   // Интерфейсы должны содержать только пустые публичные методы
} 
class A {
    protected prop1;   // Пропущен знак $ при объявлении переменой
    private prop2;    // Пропущен знак $ при объявлении переменой

    function funcA(){    // Не указан модификатор доступа
       return $this->prop2;
    }
}
class B extends A {
    function funcB(){    // Не указан модификатор доступа.
       return $this->prop1;
    }
}
class C extends B implements MyInt {
    function funcB(){    // Не указан модификатор доступа и вообще это не нужное дублирование кода.
                         // Функция funcB() с таким же содержимым есть в классе B. Она имеет смысл в этом 
                         // классе только если будет измененна логика работы метода
       return $this->prop1;
    }
    private function funcP(){   // Функция должна быть публичной, т.к. реализована на основе интерфейса 
       return 123;
    }
}  
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();    // Вызов необъявленного метода

В общем по коду:
- нет ни одного говорящего имени. Это касается и переменных, и функции, и классов, и интерфейса.
- в классе С не реализована функция funcI()
- не ошибка, но код не соответствует PSR-2. Открывающие фигурные скобки классов и методов 
должны быть на новой строке
